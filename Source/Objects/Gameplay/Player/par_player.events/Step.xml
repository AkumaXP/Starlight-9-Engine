<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="STEP" id="0">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">/// Death &amp; Respawn.
if (state == STATE_DEATH &amp;&amp; death_timer != -1)
{
    if (death_timer == -5)
    {
        // Throw the player into the air.
        if (!has_drowned) y_speed = -7;
        death_timer =  120;
        depth       = -999995;

        // Stop any special abilities.
        if (dropdash_state != 0)
        {
            dropdash_state = 0;
            dropdash_timer = 20;
            if (audio_is_playing(SFX._player_dropdash))
            {
                audio_stop(SFX._player_dropdash);
            }
        }
        if (amy_hammer_attack != 0)
        {
            amy_hammer_attack  = 0;
        }
        if (boosting)
        {
            boosting = false;
        }

        if (!cpu_flag)
        {
            // Disable game time.
            STG.add_time = false;

            // Fade out the audio.
            SFX.fadeout_flag = true;

            // Decrease lives.
            global.player_lives -= 1;
        }

        // Play death/drown sound.
        if (!has_drowned)
        {
            audio_play(SFX._player_die, SFX.sfx_volume, 1, 0, 0);
        }
        else
        {
            audio_play(SFX._player_drowned, SFX.sfx_volume, 1, 0, 0);
        }

        // Stop flight sounds.
        if (audio_is_playing(SFX._player_flying))
        {
            audio_stop(SFX._player_flying);
        }
        if (audio_is_playing(SFX._player_flying_drop))
        {
            audio_stop(SFX._player_flying_drop);
        }
    }

    // Add Gravity:
    if (!has_drowned)
    {
        y_speed += 0.21875;
    }
    else
    {
        y_speed += 0.0625;
    }
    y += y_speed;

    // Decrease death timer.
    if (death_timer &gt; 0)
    {
        death_timer -= 1;
    }
    else if (death_timer == 0)
    {
        if (!cpu_flag)
        {
            death_timer = -1;

            // If we have more than 0 lives, restart the room, otherwise, trigger a game over.
            if (global.player_lives &gt; 0)
            {
                // Check for a time over:
                if (global.limit_time &amp;&amp; STG.game_time &gt;= 599999)
                {
                    instance_create(0, 0, obj_time_over);
                }
                else
                {
                    room_fade_to(room);
                }
            }
            else
            {
                global.previous_room = room;
                instance_create(0, 0, obj_game_over);

                // Reset checkpoint variables:
                global.checkpoint_x = -1;
                global.checkpoint_y = -1;
                global.checkpoint_t =  0;
            }
        }
        else
        {
            player_state_respawn(true);
            death_timer = -5;

            // Destroy any shields:
            if (shield_index != 0)
            {
                with (shield_object) instance_destroy();
            }
        }
    }
}

if (state != STATE_RESPAWN &amp;&amp; state != STATE_DEATH)
{
    // Die from heights.
    if (STG.zone_death_height != -1)
    {
        if (y &gt;= STG.zone_death_height)
        {
            state = STATE_DEATH;
        }
    }
}

// Respawning:
player_state_respawn(false);
</argument>
      </arguments>
    </action>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">/// Terrain &amp; Instance Interaction.

// Exit in the following states:
if (state == STATE_DEATH || state == STATE_RESPAWN) exit;

// Reset the platform check if no longer colliding with a platform.
if (!place_meeting(x, y, par_platform) &amp;&amp; platform_check)
{
    platform_check = false;
}

// Handle collision with moving platforms.
// This needs to be done before movement to properly work.
player_handle_platforms();

// Limit horizontal speed if applicable:
if (x_speed_limit)
{
    x_speed = clamp(x_speed, -x_speed_max, x_speed_max);
}

// Calculate movement steps &amp; samples:
var x_steps, x_samples;
x_steps   = 1 + floor(abs(x_speed) / 13);
x_samples = x_speed / x_steps;

// Move horizontally:
repeat (x_steps)
{
    x += dcos(angle) * x_samples;
    y -= dsin(angle) * x_samples;

    // Move outside of terrain if stuck:
    while (x_samples &gt; 0 &amp;&amp; player_collision_check(COL_RIGHT, MASK_MID, x, y, angle))
    {
        x -= dcos(angle);
        y += dsin(angle);
    }
    while (x_samples &lt; 0 &amp;&amp; player_collision_check(COL_LEFT, MASK_MID, x, y, angle))
    {
        x += dcos(angle);
        y -= dsin(angle);
    }

    // Object handling:
    player_handle_list();

    // Terrain/slope collision:
    if (ground)
    {
        while (player_collision_check(COL_MAIN, x, y))
        {
            x -= dsin(angle);
            y -= dcos(angle);
        }
        if (player_collision_check(COL_SLOPE, MASK_MID, x, y, angle))
        {
            while (!player_collision_check(COL_MAIN, x, y))
            {
                x += dsin(angle);
                y += dcos(angle);
            }
        }

        // Get new angles:
        if (col_rotate_flag)
        {
            if ((!col_edge_skip &amp;&amp; player_collision_check(COL_LEFT_EDGE, x, y, angle) &amp;&amp; player_collision_check(COL_RIGHT_EDGE, x, y, angle)) || col_edge_skip)
            {
                if (col_edge_exception)
                {
                    var angle_temp;
                    angle_temp = player_get_angle(x, y, angle);
                    if ((angle_temp &gt;= 60 &amp;&amp; angle_temp &lt;= 90) || (angle_temp &gt;= 240 &amp;&amp; angle_temp &lt;= 300))
                    {
                        if (!player_collision_check(COL_EDGE_LINE))
                        {
                            ground = false;
                            break;
                        }
                        else player_set_angle(angle_temp);
                    }
                }
                else player_set_angle(player_get_angle(x, y, angle));
            }
        }
        else player_set_angle(global.gravity_angle);
    }

    // Object handling:
    player_handle_list();
}

// Limit vertical speed if applicable:
if (y_speed_limit)
{
    y_speed = clamp(y_speed, -y_speed_max, y_speed_max);
}

if (!ground)
{
    // Calculate movement steps &amp; samples:
    var y_steps, y_samples;
    y_steps   = 1 + floor(abs(y_speed) / 13);
    y_samples = y_speed / y_steps;

    // Move vertically:
    repeat (y_steps)
    {
        x += dsin(angle) * y_samples;
        y += dcos(angle) * y_samples;

        // Move outside of terrain if stuck:
        while (y_samples &lt; 0 &amp;&amp; player_collision_check(COL_TOP, MASK_MID, x, y, 0))
        {
            x += dsin(angle);
            y += dcos(angle);
        }
        while (y_samples &gt; 0 &amp;&amp; player_collision_check(COL_BOTTOM, MASK_MID, x, y, 0))
        {
            x -= dsin(angle);
            y -= dcos(angle);
        }

        // Object handling:
        player_handle_list();

        // Check for landing:
        if (y_speed &gt;= 0 &amp;&amp; player_collision_check(COL_BOTTOM, MASK_BIG, x, y, 0))
        {
            // Calculate and set angles:
            if (col_rotate_flag)
            {
                if (!col_edge_skip)
                {
                    if (player_collision_check(COL_LEFT_EDGE, x, y, 0) &amp;&amp; player_collision_check(COL_RIGHT_EDGE, x, y, 0))
                    {
                        player_set_angle(player_get_angle(x, y, angle));
                    }
                    else
                    {
                        player_set_angle(global.gravity_angle);
                    }
                }
                else
                {
                    player_set_angle(player_get_angle(x, y, angle));
                }
            }
            else
            {
                player_set_angle(global.gravity_angle);
            }

            // Change horizontal speed upon landing on uneven terrain.
            if (abs(x_speed) &lt;= abs(y_speed) &amp;&amp; angle_relative &gt;= 22.5 &amp;&amp; angle_relative &lt;= 337.5)
            {
                x_speed = y_speed * -sign(dsin(angle_relative));
                if (angle_relative &lt; 45 || angle_relative &gt; 315)
                {
                    x_speed *= 0.5;
                }
            }

            // Set ground flag.
            ground = true;
        }

        // Check for a ceiling:
        if (y_speed &lt; 0 &amp;&amp; player_collision_check(COL_TOP, MASK_LARGE, x, y, 0) &amp;&amp; !player_collision_check(COL_TOP_OBJECT, MASK_LARGE, x, y, 0, par_obstacle) &amp;&amp; col_ceiling_movement)
        {
            // Set angles:
            player_set_angle(180);

            // Check if it's possible to attach to the ceiling:
            if (player_collision_check(COL_LEFT_EDGE, x, y, angle) &amp;&amp; player_collision_check(COL_RIGHT_EDGE, x, y, angle))
            {
                // Calculate and set new angles:
                player_set_angle(player_get_angle(x, y, angle));
                
                // Check if the ceiling is steep enough to grab on to:
                if (angle_relative &lt; 135 || angle_relative &gt; 225)
                {
                    // Set horizontal speed and grab onto the ceiling.
                    x_speed = y_speed * -sign(dsin(angle_relative));
                    ground  = true;
                }
                else // Otherwise, detach from the ceiling.
                {
                    player_set_angle(global.gravity_angle);
                    y_speed = 0;
                }
            }
            else // Otherwise, reset angle and vertical speed.
            {
                player_set_angle(global.gravity_angle);
                y_speed = 0;
            }
        }

        // Perform another wall stuck check to fix any more bugs that might occur:
        while (player_collision_check(COL_RIGHT, MASK_MID, x, y, angle))
        {
            x -= dcos(angle);
            y += dsin(angle);
        }
        while (player_collision_check(COL_LEFT, MASK_MID, x, y, angle))
        {
            x += dcos(angle);
            y -= dsin(angle);
        }

        // Perform terrain/slope collision again to fix any landing bugs:
        if (player_collision_check(COL_BOTTOM, MASK_BIG, x, y, angle))
        {
            while (player_collision_check(COL_MAIN, x, y))
            {
                x -= dsin(angle);
                y -= dcos(angle);
            }
            if (player_collision_check(COL_SLOPE, MASK_MID, x, y, angle))
            {
                while (!player_collision_check(COL_MAIN, x, y))
                {
                    x += dsin(angle);
                    y += dcos(angle);
                }
            }
        }

        // Object handling:
        player_handle_list();
    }
}

// Fall/launch off the tile if the edge sensors are no longer detecting a collision:
repeat (x_steps * 2)
{
    if (ground &amp;&amp; angle != 0 &amp;&amp; ((x_speed &lt;= 0 &amp;&amp; !player_collision_check(COL_LEFT_EDGE, x, y, angle)) || (x_speed &gt;= 0 &amp;&amp; !player_collision_check(COL_RIGHT_EDGE, x, y, angle))))
    {
        // Launch off ramps:
        if (col_launch_flag)
        {
            if (angle != 90 &amp;&amp; angle != 270 &amp;&amp; angle != 180 &amp;&amp; col_launch_angle &gt; -1 &amp;&amp; col_launch_direction != 0 &amp;&amp; sign(x_speed) == col_launch_direction)
            {
                // Disable wall collisions to properly launch:
                disable_wallstop = true;
                if (alarm[0] == -1)
                {
                    alarm[0] = 15;
                }

                // Set new angles:
                player_set_angle(sign(x_speed) * col_launch_angle);

                // Set speeds:
                y_speed = -dsin(angle_relative) * x_speed;
                x_speed =  dcos(angle_relative) * x_speed;
                ground  =  false;
            }
            else // Fall off tiles.
            {
                y_speed = -(dsin(angle) * x_speed);
                x_speed =   dcos(angle) * x_speed;
                ground  =   false;
            }
        }
    }
}
</argument>
      </arguments>
    </action>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">/// Horizontal Movement.

// Exit in the following states:
if (state == STATE_DEATH || state == STATE_RESPAWN || !x_allow) exit;

// Handle acceleration/deceleration.
if (state == STATE_DEFAULT || state == STATE_BALANCE || (state == STATE_JUMP &amp;&amp; !jump_lock) || state == STATE_SKID || state == STATE_FLY || state == STATE_SPRING || state == STATE_CORKSCREW || state == STATE_CORKSCREW_ROLL || state == STATE_GLIDE_DROP)
{
    // Store input direction:
    var input_dir;
    input_dir = input_right - input_left;

    // Ground acceleration:
    if (ground)
    {
        if (input_dir != 0)
        {
            if (input_lock_timer == 0)
            {
                // Decelerate:
                if (x_speed != 0 &amp;&amp; sign(x_speed) != input_dir)
                {
                    x_speed += x_deceleration * input_dir;
                    if (sign(x_speed) == input_dir)
                    {
                        x_speed = x_deceleration * input_dir;
                    }
                }
                else // Accelerate.
                {
                    if (abs(x_speed) &lt; x_speed_top)
                    {
                        x_speed += x_acceleration * input_dir;
                        if (abs(x_speed) &gt; x_speed_top)
                        {
                            x_speed = x_speed_top * input_dir;
                        }
                    }
                }
            }
        }
        else
        {
            // Friction:
            x_speed -= min(abs(x_speed), x_acceleration) * sign(x_speed);
        }
    }
    else // Air acceleration.
    {
        if (input_dir != 0)
        {
            if (abs(x_speed) &lt; x_speed_top || sign(x_speed) != input_dir)
            {
                x_speed += (x_acceleration * 2) * input_dir;
                if (abs(x_speed) &gt; x_speed_top &amp;&amp; sign(x_speed) == input_dir)
                {
                    x_speed = x_speed_top * input_dir;
                }
            }
        }

        // Air drag:
        if (y_speed &lt; 0 &amp;&amp; y_speed &gt; -4)
        {
            x_speed -= floor(x_speed / 0.125) / 256;
        }
    }
}

// Decelerate/accelerate along slopes:
if (state != STATE_SLIDE &amp;&amp; ground)
{
    // Check if we're not moving along a ceiling:
    if (angle_relative &lt; 135 || angle_relative &gt; 225)
    {
        if (state == STATE_ROLL)
        {
            // Rolling up a slope:
            if (sign(x_speed) == sign(dsin(angle_relative)))
            {
                x_speed -= dsin(angle_relative) * roll_decel_up;
            }
            else // Rolling down a slope.
            {
                x_speed -= dsin(angle_relative) * roll_decel_down;
            }
        }
        else
        {
            if (angle_relative &gt;= 22.5 &amp;&amp; angle_relative &lt;= 337.5)
            {
                x_speed -= dsin(angle_relative) * 0.125;
            }
        }
    }
}

// Fall if there's not enough speed to stay on ground:
if (angle_relative &gt;= 45 &amp;&amp; angle_relative &lt;= 315 &amp;&amp; ground &amp;&amp; abs(x_speed) &lt; 2.5 &amp;&amp; !tunnel_lock)
{
    if (angle_relative &gt;= 90 &amp;&amp; angle_relative &lt;= 270)
    {
        y_speed = -dsin(angle_relative) * x_speed;
        x_speed =  dcos(angle_relative) * x_speed;
        ground  =  false;
    }
    else
    {
        input_lock_timer = 30;
    }
}

// Get new angles:
if (ground &amp;&amp; player_collision_check(COL_LEFT_EDGE, x, y, angle) &amp;&amp; player_collision_check(COL_RIGHT_EDGE, x, y, angle))
{
    player_set_angle(player_get_angle(x, y, angle));
}
else
{
    player_set_angle(global.gravity_angle);
}

// Come to a stop when colliding with a wall:
if (!disable_wallstop)
{
    if ((x_speed &gt;= 0 &amp;&amp; player_collision_check(COL_RIGHT, MASK_BIG, x, y, angle)) || (x_speed &lt;= 0 &amp;&amp; player_collision_check(COL_LEFT, MASK_BIG, x, y, angle)))
    {
        x_speed = 0;
    }
}
</argument>
      </arguments>
    </action>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">/// Vertical Movement.

// Exit in the following states:
if (state == STATE_DEATH || state == STATE_RESPAWN || !y_allow) exit;

if (ground)
{
    // Return to the normal state.
    if (y_speed != 0) y_speed = 0;

    if ((state == STATE_JUMP &amp;&amp; dropdash_state &lt; 2) || state == STATE_FLY || state == STATE_HURT || state == STATE_SPRING || state == STATE_CARRY)
    {
        // Reset X-Speed if hurt:
        if (state == STATE_HURT)
        {
            x_speed = 0;
        }

        // Reset gravity after flying.
        if (state == STATE_FLY)
        {
            y_acceleration = y_accel_common;
        }
        state = STATE_DEFAULT;
    }

    // Check if there's no longer any floor below the player:
    if (!player_collision_check(COL_BOTTOM, MASK_BIG, x, y, angle))
    {
        ground = false;
        player_set_angle(global.gravity_angle);
    }
}
else
{
    // Add gravity:
    if (state != STATE_GLIDE &amp;&amp; state != STATE_CLIMB &amp;&amp; state != STATE_CORKSCREW &amp;&amp; state != STATE_CORKSCREW_ROLL &amp;&amp; state != STATE_CARRY)
    {
        y_speed = min(y_speed + y_acceleration, 16);
    }
}

// Revert spring state.
if (y_speed &gt; 0 &amp;&amp; state == STATE_SPRING)
{
    if (animation_index == "SPRING" || (animation_index == "CORKSCREW" &amp;&amp; animation_finished))
    {
        state           = STATE_DEFAULT;
        animation_index = "WALK";
    }
}
</argument>
      </arguments>
    </action>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">/// States.

// Exit in the following states:
if (state == STATE_DEATH) exit;

// NOTE: if you want to add a state that initiates while jumping, call its script before the jumping state script.
// Otherwise, the state will not execute.

// Character-specific states.
switch (character_id)
{
    // Classic Sonic:
    case CHAR_SONIC:
    {
        player_state_shield();
        player_state_dropdash();
        if (!cpu_flag) player_state_peelout();
        break;
    }

    // Tails:
    case CHAR_TAILS:
    {
        player_state_fly();
        break;
    }

    // Knuckles:
    case CHAR_KNUCKLES:
    {
        player_state_glide();
        player_state_climb();
        player_state_slide();
        break;
    }

    // Amy:
    case CHAR_AMY:
    {
        player_state_hammer();
        break;
    }

    // Modern Sonic:
    case CHAR_MODERN:
    {
        player_state_boost();
        if (!cpu_flag) player_state_homing();
        break;
    }
}

// Common states.
player_state_carry();
player_state_hang();
player_state_jump();
player_state_lookup();
player_state_crouch();
player_state_spindash();
player_state_roll();
player_state_skid();
player_state_push();
player_state_balance();
player_state_swap();
player_state_grind();
</argument>
      </arguments>
    </action>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">/// Invincibility &amp; Superspeed Timers.

// Exit in the following states:
if (state == STATE_DEATH) exit;

// Decrease invincibility timer.
if (invincibility_timer &gt; -1)
{
    invincibility_timer -= 1;
    if (invincibility_timer &lt;= 0)
    {
        invincibility_type  =  0;
        invincibility_timer = -1;

        // Stop invincibility jingle.
        if (audio_is_playing(SFX._jingle_invincibility) &amp;&amp; !cpu_flag)
        {
            audio_stop(SFX._jingle_invincibility);
        }
    }
}

// Start invincibility timer once we land after being hit.
if (invincibility_type == 1 &amp;&amp; invincibility_timer == -1 &amp;&amp; state != STATE_HURT &amp;&amp; state != STATE_RESPAWN)
{
    invincibility_timer = 120;
}

// Hide shields when invincible.
if (shield_object != noone)
{
    shield_object.visible = (invincibility_type != 2);
}

// Create invincibility sparkles (credit to Tpot).
if (invincibility_type == 2 &amp;&amp; invincibility_timer mod 5 == 0)
{
    invincibility_angle = wrap_angle(invincibility_angle + 45);
    var xx, yy;
    xx = dcos(invincibility_angle) * 16;
    yy = dsin(invincibility_angle) * 16;
    create_effect(spr_invincibility_sparkle, random_range(0.4, 0.8), x + xx, y + yy - 6, -1, 0);
    create_effect(spr_invincibility_sparkle, random_range(0.4, 0.8), x - xx, y - yy - 6, -1, 0);
}

// Decrease superspeed timer.
if (superspeed_timer &gt; 0)
{
    superspeed_timer -= 1;
    if (superspeed_timer &lt;= 0)
    {
        superspeed_timer = 0;
        afterimage_draw  = false;
    }
}
</argument>
      </arguments>
    </action>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">/// Underwater handling.

// Don't run in certain cases:
if (state != STATE_DEATH &amp;&amp; state != STATE_RESPAWN &amp;&amp; !instance_exists(obj_results))
{
    if (underwater)
    {
        // Destroy the countdown if we have a bubble shield and keep the drown timer fixed.
        if (shield_index == SHIELD_BUBBLE)
        {
            drown_timer = 1800;
            if (instance_exists(drown_counter))
            {
                with (drown_counter) instance_destroy();
                drown_counter = noone;
            }
            
            if (!cpu_flag)
            {
                if (audio_is_playing(SFX._jingle_drown))
                {
                    audio_stop(SFX._jingle_drown);
                }
            }
            exit;
        }

        // Decrease our drown timer.
        if (drown_timer &gt; 0)
        {
            drown_timer -= 1;
        }

        // Start the drowning jingle and create the countdown timer.
        if (drown_timer == 650)
        {
            if (!cpu_flag)
            {
                if (!audio_is_playing(SFX._jingle_drown))
                {
                    audio_play(SFX._jingle_drown, SFX.bgm_volume, 1, 0, 1);
                }
            }
            
            if (instance_number(obj_water_alarm) &lt; 2)
            {
                drown_counter        = instance_create(x, y - 32, obj_water_alarm);
                drown_counter.parent = id;
            }
        }

        // Kill the player.
        if (drown_timer == 0)
        {
            drown_timer = 1800;
            state       = STATE_DEATH;
            has_drowned = true;
            
            if (!cpu_flag)
            {
                if (audio_is_playing(SFX._jingle_drown))
                {
                    audio_stop(SFX._jingle_drown);
                }
            }
        }

        // Breathing state.
        if (state == STATE_BREATH)
        {
            if (!ground)
            {
                if (bubble_timer &lt; 1)
                {
                    x_speed = 0;
                    y_speed = 0;
                }
                
                if (input_left || input_right)
                {
                    x_speed += animation_direction * 0.025;
                }
                
                if (bubble_timer &lt; 20)
                {
                    bubble_timer += 1;
                }
                else
                {
                    bubble_timer    = 0;
                    animation_index = "WALK";
                    state           = STATE_DEFAULT;
                }
                
                // Reset drown counter:
                drown_timer = 1800;
                if (instance_exists(drown_counter))
                {
                    with (drown_counter) instance_destroy();
                    drown_counter = noone;
                }
                
                // Stop drowning jingle.
                if (!cpu_flag)
                {
                    if (audio_is_playing(SFX._jingle_drown))
                    {
                        audio_stop(SFX._jingle_drown);
                    }
                }
            }
            else
            {
                state       = STATE_DEFAULT;
                drown_timer = 1800;
                if (instance_exists(drown_counter))
                {
                    with (drown_counter) instance_destroy();
                    drown_counter = noone;
                }
                
                if (!cpu_flag)
                {
                    if (audio_is_playing(SFX._jingle_drown))
                    {
                        audio_stop(SFX._jingle_drown);
                    }
                }
            }
        }
        else // Reset bubble timer.
        {
            bubble_timer = 0;
        }

        // Alarm sounds.
        if (!cpu_flag)
        {
            if (drown_timer mod 400 == 0)
            {
                if (!audio_is_playing(SFX._jingle_drown))
                {
                    audio_play(SFX._general_alarm_count, SFX.sfx_volume, 1, 0, 0);
                }
            }
        }

        // Air bubbles. 
        if (drown_timer mod 78 == 0 &amp;&amp; drown_timer &gt; 600)
        {
            bubble              = instance_create(x + irandom_range(-7, 8), y - 6, obj_water_air_bubble);
            bubble.bubble_index = choose(0, 1, 2, 1, 3);
        }
    }
}
else
{
    drown_timer = 1800;
    if (instance_exists(drown_counter))
    {
        with (drown_counter) instance_destroy();
        drown_counter = noone;
    }
    
    if (!cpu_flag)
    {
        if (audio_is_playing(SFX._jingle_drown))
        {
            audio_stop(SFX._jingle_drown);
        }
    }
}

// Above water, reset timers, stop drowning jingle and destroy the drown counter.
if (!underwater)
{
    drown_timer = 1800;
    if (instance_exists(drown_counter))
    {
        with (drown_counter) instance_destroy();
        drown_counter = noone;
    }
    
    if (!cpu_flag)
    {
        if (audio_is_playing(SFX._jingle_drown))
        {
            audio_stop(SFX._jingle_drown);
        }
    }
}

// Drowning bubbles.
if (state == STATE_DEATH &amp;&amp; has_drowned)
{
    if (breath_timer != 0)
    {
        breath_timer -= 1;
        if (random(4) &gt;= 2)
        {
            bubble              = instance_create(x + irandom_range(-7, 8), y - 6, obj_water_air_bubble);
            bubble.bubble_index = choose(0, 1, 2, 1, 3);
            bubble.depth        = -999996;
        }
    }
}
</argument>
      </arguments>
    </action>
  </actions>
</event>
